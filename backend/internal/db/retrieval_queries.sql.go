// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: retrieval_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getActiveChargebackByBusinessKey = `-- name: GetActiveChargebackByBusinessKey :one
SELECT id, reporting_source, fund, business_line, region, location_system, program, al_num, source_num, agreement_num, title, alc, customer_tas, task_subtask, class_id, customer_name, org_code, document_date, accomp_date, assigned_rebill_drn, chargeback_amount, statement, bd_doc_num, vendor, articles_services, current_status, reason_code, action, alc_to_rebill, tas_to_rebill, line_of_accounting_rebill, special_instruction, new_ipac_document_ref, created_at, updated_at, is_active, days_old, agency_id, bureau_code FROM active_chargebacks_with_vendor_info
WHERE bd_doc_num = $1 AND al_num = $2
`

type GetActiveChargebackByBusinessKeyParams struct {
	BdDocNum string `json:"bd_doc_num"`
	AlNum    int16  `json:"al_num"`
}

// Fetches a single active chargeback by business key
func (q *Queries) GetActiveChargebackByBusinessKey(ctx context.Context, arg GetActiveChargebackByBusinessKeyParams) (ActiveChargebacksWithVendorInfo, error) {
	row := q.db.QueryRow(ctx, getActiveChargebackByBusinessKey, arg.BdDocNum, arg.AlNum)
	var i ActiveChargebacksWithVendorInfo
	err := row.Scan(
		&i.ID,
		&i.ReportingSource,
		&i.Fund,
		&i.BusinessLine,
		&i.Region,
		&i.LocationSystem,
		&i.Program,
		&i.AlNum,
		&i.SourceNum,
		&i.AgreementNum,
		&i.Title,
		&i.Alc,
		&i.CustomerTas,
		&i.TaskSubtask,
		&i.ClassID,
		&i.CustomerName,
		&i.OrgCode,
		&i.DocumentDate,
		&i.AccompDate,
		&i.AssignedRebillDrn,
		&i.ChargebackAmount,
		&i.Statement,
		&i.BdDocNum,
		&i.Vendor,
		&i.ArticlesServices,
		&i.CurrentStatus,
		&i.ReasonCode,
		&i.Action,
		&i.AlcToRebill,
		&i.TasToRebill,
		&i.LineOfAccountingRebill,
		&i.SpecialInstruction,
		&i.NewIpacDocumentRef,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.DaysOld,
		&i.AgencyID,
		&i.BureauCode,
	)
	return i, err
}

const getActiveChargebackByID = `-- name: GetActiveChargebackByID :one
SELECT id, reporting_source, fund, business_line, region, location_system, program, al_num, source_num, agreement_num, title, alc, customer_tas, task_subtask, class_id, customer_name, org_code, document_date, accomp_date, assigned_rebill_drn, chargeback_amount, statement, bd_doc_num, vendor, articles_services, current_status, reason_code, action, alc_to_rebill, tas_to_rebill, line_of_accounting_rebill, special_instruction, new_ipac_document_ref, created_at, updated_at, is_active, days_old, agency_id, bureau_code FROM active_chargebacks_with_vendor_info
WHERE id = $1
`

// Fetches a single active chargeback by its primary key from the view.
func (q *Queries) GetActiveChargebackByID(ctx context.Context, id int64) (ActiveChargebacksWithVendorInfo, error) {
	row := q.db.QueryRow(ctx, getActiveChargebackByID, id)
	var i ActiveChargebacksWithVendorInfo
	err := row.Scan(
		&i.ID,
		&i.ReportingSource,
		&i.Fund,
		&i.BusinessLine,
		&i.Region,
		&i.LocationSystem,
		&i.Program,
		&i.AlNum,
		&i.SourceNum,
		&i.AgreementNum,
		&i.Title,
		&i.Alc,
		&i.CustomerTas,
		&i.TaskSubtask,
		&i.ClassID,
		&i.CustomerName,
		&i.OrgCode,
		&i.DocumentDate,
		&i.AccompDate,
		&i.AssignedRebillDrn,
		&i.ChargebackAmount,
		&i.Statement,
		&i.BdDocNum,
		&i.Vendor,
		&i.ArticlesServices,
		&i.CurrentStatus,
		&i.ReasonCode,
		&i.Action,
		&i.AlcToRebill,
		&i.TasToRebill,
		&i.LineOfAccountingRebill,
		&i.SpecialInstruction,
		&i.NewIpacDocumentRef,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.DaysOld,
		&i.AgencyID,
		&i.BureauCode,
	)
	return i, err
}

const getActiveDelinquencyByBusinessKey = `-- name: GetActiveDelinquencyByBusinessKey :one
SELECT id, reporting_source, business_line, billed_total_amount, principle_amount, interest_amount, penalty_amount, administration_charges_amount, debit_outstanding_amount, credit_total_amount, credit_outstanding_amount, title, document_date, address_code, vendor, debt_appeal_forbearance, statement, document_number, vendor_code, collection_due_date, current_status, pfs_poc, gsa_poc, customer_poc, pfs_contacts, open_date, reconciled_date, created_at, updated_at, is_active, days_old, agency_id, bureau_code FROM active_nonipac_with_vendor_info
WHERE document_number = $1
`

// Fetches a single active delinquency by business key
func (q *Queries) GetActiveDelinquencyByBusinessKey(ctx context.Context, documentNumber string) (ActiveNonipacWithVendorInfo, error) {
	row := q.db.QueryRow(ctx, getActiveDelinquencyByBusinessKey, documentNumber)
	var i ActiveNonipacWithVendorInfo
	err := row.Scan(
		&i.ID,
		&i.ReportingSource,
		&i.BusinessLine,
		&i.BilledTotalAmount,
		&i.PrincipleAmount,
		&i.InterestAmount,
		&i.PenaltyAmount,
		&i.AdministrationChargesAmount,
		&i.DebitOutstandingAmount,
		&i.CreditTotalAmount,
		&i.CreditOutstandingAmount,
		&i.Title,
		&i.DocumentDate,
		&i.AddressCode,
		&i.Vendor,
		&i.DebtAppealForbearance,
		&i.Statement,
		&i.DocumentNumber,
		&i.VendorCode,
		&i.CollectionDueDate,
		&i.CurrentStatus,
		&i.PfsPoc,
		&i.GsaPoc,
		&i.CustomerPoc,
		&i.PfsContacts,
		&i.OpenDate,
		&i.ReconciledDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.DaysOld,
		&i.AgencyID,
		&i.BureauCode,
	)
	return i, err
}

const getActiveDelinquencyByID = `-- name: GetActiveDelinquencyByID :one
SELECT id, reporting_source, business_line, billed_total_amount, principle_amount, interest_amount, penalty_amount, administration_charges_amount, debit_outstanding_amount, credit_total_amount, credit_outstanding_amount, title, document_date, address_code, vendor, debt_appeal_forbearance, statement, document_number, vendor_code, collection_due_date, current_status, pfs_poc, gsa_poc, customer_poc, pfs_contacts, open_date, reconciled_date, created_at, updated_at, is_active, days_old, agency_id, bureau_code FROM active_nonipac_with_vendor_info
WHERE id = $1
`

// Fetches a single active delinquency by its primary key from the view.
func (q *Queries) GetActiveDelinquencyByID(ctx context.Context, id int64) (ActiveNonipacWithVendorInfo, error) {
	row := q.db.QueryRow(ctx, getActiveDelinquencyByID, id)
	var i ActiveNonipacWithVendorInfo
	err := row.Scan(
		&i.ID,
		&i.ReportingSource,
		&i.BusinessLine,
		&i.BilledTotalAmount,
		&i.PrincipleAmount,
		&i.InterestAmount,
		&i.PenaltyAmount,
		&i.AdministrationChargesAmount,
		&i.DebitOutstandingAmount,
		&i.CreditTotalAmount,
		&i.CreditOutstandingAmount,
		&i.Title,
		&i.DocumentDate,
		&i.AddressCode,
		&i.Vendor,
		&i.DebtAppealForbearance,
		&i.Statement,
		&i.DocumentNumber,
		&i.VendorCode,
		&i.CollectionDueDate,
		&i.CurrentStatus,
		&i.PfsPoc,
		&i.GsaPoc,
		&i.CustomerPoc,
		&i.PfsContacts,
		&i.OpenDate,
		&i.ReconciledDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.DaysOld,
		&i.AgencyID,
		&i.BureauCode,
	)
	return i, err
}

const getChargebackForUpdate = `-- name: GetChargebackForUpdate :one
SELECT id, reporting_source, fund, business_line, region, location_system, program, al_num, source_num, agreement_num, title, alc, customer_tas, task_subtask, class_id, customer_name, org_code, document_date, accomp_date, assigned_rebill_drn, chargeback_amount, statement, bd_doc_num, vendor, articles_services, current_status, reason_code, action, alc_to_rebill, tas_to_rebill, line_of_accounting_rebill, special_instruction, new_ipac_document_ref, created_at, updated_at, is_active FROM chargeback
WHERE id = $1 LIMIT 1
`

// Fetches a single chargeback directly from the base table for updating.
func (q *Queries) GetChargebackForUpdate(ctx context.Context, id int64) (Chargeback, error) {
	row := q.db.QueryRow(ctx, getChargebackForUpdate, id)
	var i Chargeback
	err := row.Scan(
		&i.ID,
		&i.ReportingSource,
		&i.Fund,
		&i.BusinessLine,
		&i.Region,
		&i.LocationSystem,
		&i.Program,
		&i.AlNum,
		&i.SourceNum,
		&i.AgreementNum,
		&i.Title,
		&i.Alc,
		&i.CustomerTas,
		&i.TaskSubtask,
		&i.ClassID,
		&i.CustomerName,
		&i.OrgCode,
		&i.DocumentDate,
		&i.AccompDate,
		&i.AssignedRebillDrn,
		&i.ChargebackAmount,
		&i.Statement,
		&i.BdDocNum,
		&i.Vendor,
		&i.ArticlesServices,
		&i.CurrentStatus,
		&i.ReasonCode,
		&i.Action,
		&i.AlcToRebill,
		&i.TasToRebill,
		&i.LineOfAccountingRebill,
		&i.SpecialInstruction,
		&i.NewIpacDocumentRef,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getDelinquencyForUpdate = `-- name: GetDelinquencyForUpdate :one
SELECT id, reporting_source, business_line, billed_total_amount, principle_amount, interest_amount, penalty_amount, administration_charges_amount, debit_outstanding_amount, credit_total_amount, credit_outstanding_amount, title, document_date, address_code, vendor, debt_appeal_forbearance, statement, document_number, vendor_code, collection_due_date, current_status, pfs_poc, gsa_poc, customer_poc, pfs_contacts, open_date, reconciled_date, created_at, updated_at, is_active FROM nonipac
WHERE id = $1 LIMIT 1
`

// Fetches a single chargeback directly from the base table for updating.
func (q *Queries) GetDelinquencyForUpdate(ctx context.Context, id int64) (Nonipac, error) {
	row := q.db.QueryRow(ctx, getDelinquencyForUpdate, id)
	var i Nonipac
	err := row.Scan(
		&i.ID,
		&i.ReportingSource,
		&i.BusinessLine,
		&i.BilledTotalAmount,
		&i.PrincipleAmount,
		&i.InterestAmount,
		&i.PenaltyAmount,
		&i.AdministrationChargesAmount,
		&i.DebitOutstandingAmount,
		&i.CreditTotalAmount,
		&i.CreditOutstandingAmount,
		&i.Title,
		&i.DocumentDate,
		&i.AddressCode,
		&i.Vendor,
		&i.DebtAppealForbearance,
		&i.Statement,
		&i.DocumentNumber,
		&i.VendorCode,
		&i.CollectionDueDate,
		&i.CurrentStatus,
		&i.PfsPoc,
		&i.GsaPoc,
		&i.CustomerPoc,
		&i.PfsContacts,
		&i.OpenDate,
		&i.ReconciledDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getStatusHistoryForChargeback = `-- name: GetStatusHistoryForChargeback :many
SELECT
    sh.id as status_history_id, 
    sh.status,
    sh.status_date, 
    sh.notes,
    sh.user_id,
    u.first_name AS user_first_name,
    u.last_name AS user_last_name,
    u.email AS user_email
FROM
    "status_history" sh
JOIN
    "chargeback_status_merge" csm ON sh.id = csm.status_history_id
JOIN
    "user" u ON sh.user_id = u.id
WHERE
    csm.chargeback_id = $1 
ORDER BY
    sh.status_date DESC
`

type GetStatusHistoryForChargebackRow struct {
	StatusHistoryID int64              `json:"status_history_id"`
	Status          CdmsStatus         `json:"status"`
	StatusDate      pgtype.Timestamptz `json:"status_date"`
	Notes           pgtype.Text        `json:"notes"`
	UserID          int64              `json:"user_id"`
	UserFirstName   string             `json:"user_first_name"`
	UserLastName    string             `json:"user_last_name"`
	UserEmail       string             `json:"user_email"`
}

// Fetches Status History for Chargebacks
func (q *Queries) GetStatusHistoryForChargeback(ctx context.Context, chargebackID int64) ([]GetStatusHistoryForChargebackRow, error) {
	rows, err := q.db.Query(ctx, getStatusHistoryForChargeback, chargebackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusHistoryForChargebackRow
	for rows.Next() {
		var i GetStatusHistoryForChargebackRow
		if err := rows.Scan(
			&i.StatusHistoryID,
			&i.Status,
			&i.StatusDate,
			&i.Notes,
			&i.UserID,
			&i.UserFirstName,
			&i.UserLastName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusHistoryForDelinquencies = `-- name: GetStatusHistoryForDelinquencies :many
SELECT
    sh.id as status_history_id, 
    sh.status,
    sh.status_date, 
    sh.notes,
    sh.user_id,
    u.first_name AS user_first_name,
    u.last_name AS user_last_name,
    u.email AS user_email
FROM
    "status_history" sh
JOIN
    "nonipac_status_merge" nsm ON sh.id = nsm.status_history_id
JOIN
    "user" u ON sh.user_id = u.id
WHERE
    nsm.nonipac_id = $1 
ORDER BY
    sh.status_date DESC
`

type GetStatusHistoryForDelinquenciesRow struct {
	StatusHistoryID int64              `json:"status_history_id"`
	Status          CdmsStatus         `json:"status"`
	StatusDate      pgtype.Timestamptz `json:"status_date"`
	Notes           pgtype.Text        `json:"notes"`
	UserID          int64              `json:"user_id"`
	UserFirstName   string             `json:"user_first_name"`
	UserLastName    string             `json:"user_last_name"`
	UserEmail       string             `json:"user_email"`
}

// Fetches Status History for Delinquencies
func (q *Queries) GetStatusHistoryForDelinquencies(ctx context.Context, nonipacID int64) ([]GetStatusHistoryForDelinquenciesRow, error) {
	rows, err := q.db.Query(ctx, getStatusHistoryForDelinquencies, nonipacID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusHistoryForDelinquenciesRow
	for rows.Next() {
		var i GetStatusHistoryForDelinquenciesRow
		if err := rows.Scan(
			&i.StatusHistoryID,
			&i.Status,
			&i.StatusDate,
			&i.Notes,
			&i.UserID,
			&i.UserFirstName,
			&i.UserLastName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, first_name, last_name, org, email, created_at, updated_at, is_active, is_admin FROM "user" WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Org,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsAdmin,
	)
	return i, err
}

const listActiveChargebacks = `-- name: ListActiveChargebacks :many
SELECT id, reporting_source, fund, business_line, region, location_system, program, al_num, source_num, agreement_num, title, alc, customer_tas, task_subtask, class_id, customer_name, org_code, document_date, accomp_date, assigned_rebill_drn, chargeback_amount, statement, bd_doc_num, vendor, articles_services, current_status, reason_code, action, alc_to_rebill, tas_to_rebill, line_of_accounting_rebill, special_instruction, new_ipac_document_ref, created_at, updated_at, is_active, days_old, agency_id, bureau_code, count(*) OVER() AS total_count
FROM active_chargebacks_with_vendor_info
ORDER BY document_date DESC
LIMIT $1
OFFSET $2
`

type ListActiveChargebacksParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListActiveChargebacksRow struct {
	ID                     int64                     `json:"id"`
	ReportingSource        ChargebackReportingSource `json:"reporting_source"`
	Fund                   ChargebackFund            `json:"fund"`
	BusinessLine           ChargebackBusinessLine    `json:"business_line"`
	Region                 int16                     `json:"region"`
	LocationSystem         pgtype.Text               `json:"location_system"`
	Program                string                    `json:"program"`
	AlNum                  int16                     `json:"al_num"`
	SourceNum              string                    `json:"source_num"`
	AgreementNum           pgtype.Text               `json:"agreement_num"`
	Title                  pgtype.Text               `json:"title"`
	Alc                    string                    `json:"alc"`
	CustomerTas            string                    `json:"customer_tas"`
	TaskSubtask            string                    `json:"task_subtask"`
	ClassID                pgtype.Text               `json:"class_id"`
	CustomerName           string                    `json:"customer_name"`
	OrgCode                string                    `json:"org_code"`
	DocumentDate           pgtype.Date               `json:"document_date"`
	AccompDate             pgtype.Date               `json:"accomp_date"`
	AssignedRebillDrn      pgtype.Text               `json:"assigned_rebill_drn"`
	ChargebackAmount       pgtype.Numeric            `json:"chargeback_amount"`
	Statement              string                    `json:"statement"`
	BdDocNum               string                    `json:"bd_doc_num"`
	Vendor                 string                    `json:"vendor"`
	ArticlesServices       pgtype.Text               `json:"articles_services"`
	CurrentStatus          CdmsStatus                `json:"current_status"`
	ReasonCode             NullChargebackReasonCode  `json:"reason_code"`
	Action                 NullChargebackAction      `json:"action"`
	AlcToRebill            pgtype.Text               `json:"alc_to_rebill"`
	TasToRebill            pgtype.Text               `json:"tas_to_rebill"`
	LineOfAccountingRebill pgtype.Text               `json:"line_of_accounting_rebill"`
	SpecialInstruction     pgtype.Text               `json:"special_instruction"`
	NewIpacDocumentRef     pgtype.Text               `json:"new_ipac_document_ref"`
	CreatedAt              pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz        `json:"updated_at"`
	IsActive               bool                      `json:"is_active"`
	DaysOld                interface{}               `json:"days_old"`
	AgencyID               string                    `json:"agency_id"`
	BureauCode             string                    `json:"bureau_code"`
	TotalCount             int64                     `json:"total_count"`
}

// //go:generate mockery --name Querier --output ./mocks --outpkg mocks
// Fetches a paginated list from the active_chargebacks_with_vendor_info view.
// The view is already filtered by is_active = true.
func (q *Queries) ListActiveChargebacks(ctx context.Context, arg ListActiveChargebacksParams) ([]ListActiveChargebacksRow, error) {
	rows, err := q.db.Query(ctx, listActiveChargebacks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveChargebacksRow
	for rows.Next() {
		var i ListActiveChargebacksRow
		if err := rows.Scan(
			&i.ID,
			&i.ReportingSource,
			&i.Fund,
			&i.BusinessLine,
			&i.Region,
			&i.LocationSystem,
			&i.Program,
			&i.AlNum,
			&i.SourceNum,
			&i.AgreementNum,
			&i.Title,
			&i.Alc,
			&i.CustomerTas,
			&i.TaskSubtask,
			&i.ClassID,
			&i.CustomerName,
			&i.OrgCode,
			&i.DocumentDate,
			&i.AccompDate,
			&i.AssignedRebillDrn,
			&i.ChargebackAmount,
			&i.Statement,
			&i.BdDocNum,
			&i.Vendor,
			&i.ArticlesServices,
			&i.CurrentStatus,
			&i.ReasonCode,
			&i.Action,
			&i.AlcToRebill,
			&i.TasToRebill,
			&i.LineOfAccountingRebill,
			&i.SpecialInstruction,
			&i.NewIpacDocumentRef,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.DaysOld,
			&i.AgencyID,
			&i.BureauCode,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveDelinquencies = `-- name: ListActiveDelinquencies :many
SELECT id, reporting_source, business_line, billed_total_amount, principle_amount, interest_amount, penalty_amount, administration_charges_amount, debit_outstanding_amount, credit_total_amount, credit_outstanding_amount, title, document_date, address_code, vendor, debt_appeal_forbearance, statement, document_number, vendor_code, collection_due_date, current_status, pfs_poc, gsa_poc, customer_poc, pfs_contacts, open_date, reconciled_date, created_at, updated_at, is_active, days_old, agency_id, bureau_code, count(*) OVER() AS total_count
FROM active_nonipac_with_vendor_info
ORDER BY document_date DESC
LIMIT $1
OFFSET $2
`

type ListActiveDelinquenciesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListActiveDelinquenciesRow struct {
	ID                          int64                  `json:"id"`
	ReportingSource             NonipacReportingSource `json:"reporting_source"`
	BusinessLine                ChargebackBusinessLine `json:"business_line"`
	BilledTotalAmount           pgtype.Numeric         `json:"billed_total_amount"`
	PrincipleAmount             pgtype.Numeric         `json:"principle_amount"`
	InterestAmount              pgtype.Numeric         `json:"interest_amount"`
	PenaltyAmount               pgtype.Numeric         `json:"penalty_amount"`
	AdministrationChargesAmount pgtype.Numeric         `json:"administration_charges_amount"`
	DebitOutstandingAmount      pgtype.Numeric         `json:"debit_outstanding_amount"`
	CreditTotalAmount           pgtype.Numeric         `json:"credit_total_amount"`
	CreditOutstandingAmount     pgtype.Numeric         `json:"credit_outstanding_amount"`
	Title                       pgtype.Text            `json:"title"`
	DocumentDate                pgtype.Date            `json:"document_date"`
	AddressCode                 string                 `json:"address_code"`
	Vendor                      string                 `json:"vendor"`
	DebtAppealForbearance       bool                   `json:"debt_appeal_forbearance"`
	Statement                   string                 `json:"statement"`
	DocumentNumber              string                 `json:"document_number"`
	VendorCode                  string                 `json:"vendor_code"`
	CollectionDueDate           pgtype.Date            `json:"collection_due_date"`
	CurrentStatus               CdmsStatus             `json:"current_status"`
	PfsPoc                      pgtype.Int8            `json:"pfs_poc"`
	GsaPoc                      pgtype.Int8            `json:"gsa_poc"`
	CustomerPoc                 pgtype.Int8            `json:"customer_poc"`
	PfsContacts                 pgtype.Int2            `json:"pfs_contacts"`
	OpenDate                    pgtype.Date            `json:"open_date"`
	ReconciledDate              pgtype.Date            `json:"reconciled_date"`
	CreatedAt                   pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz     `json:"updated_at"`
	IsActive                    bool                   `json:"is_active"`
	DaysOld                     interface{}            `json:"days_old"`
	AgencyID                    string                 `json:"agency_id"`
	BureauCode                  string                 `json:"bureau_code"`
	TotalCount                  int64                  `json:"total_count"`
}

// Fetches a paginated list from the active_nonipac_with_vendor_info view.
// The view is already filtered by is_active = true.
func (q *Queries) ListActiveDelinquencies(ctx context.Context, arg ListActiveDelinquenciesParams) ([]ListActiveDelinquenciesRow, error) {
	rows, err := q.db.Query(ctx, listActiveDelinquencies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveDelinquenciesRow
	for rows.Next() {
		var i ListActiveDelinquenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.ReportingSource,
			&i.BusinessLine,
			&i.BilledTotalAmount,
			&i.PrincipleAmount,
			&i.InterestAmount,
			&i.PenaltyAmount,
			&i.AdministrationChargesAmount,
			&i.DebitOutstandingAmount,
			&i.CreditTotalAmount,
			&i.CreditOutstandingAmount,
			&i.Title,
			&i.DocumentDate,
			&i.AddressCode,
			&i.Vendor,
			&i.DebtAppealForbearance,
			&i.Statement,
			&i.DocumentNumber,
			&i.VendorCode,
			&i.CollectionDueDate,
			&i.CurrentStatus,
			&i.PfsPoc,
			&i.GsaPoc,
			&i.CustomerPoc,
			&i.PfsContacts,
			&i.OpenDate,
			&i.ReconciledDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.DaysOld,
			&i.AgencyID,
			&i.BureauCode,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
