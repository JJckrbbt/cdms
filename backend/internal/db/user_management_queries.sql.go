// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_management_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignBusinessLinesToUser = `-- name: AssignBusinessLinesToUser :exec
WITH deleted AS (
    DELETE FROM "user_business_line_access"
    WHERE user_id = $1
)
INSERT INTO "user_business_line_access" (user_id, business_line)
SELECT $1, unnest($2::chargeback_business_line[])
`

type AssignBusinessLinesToUserParams struct {
	UserID        int64                    `json:"user_id"`
	BusinessLines []ChargebackBusinessLine `json:"business_lines"`
}

// Assigns a set of business lines to a user, replacing existing ones.
// This uses a CTE to first delete old assignments, then insert new ones.
func (q *Queries) AssignBusinessLinesToUser(ctx context.Context, arg AssignBusinessLinesToUserParams) error {
	_, err := q.db.Exec(ctx, assignBusinessLinesToUser, arg.UserID, arg.BusinessLines)
	return err
}

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO "user_roles" (user_id, role_id) VALUES ($1, $2)
ON CONFLICT (user_id, role_id) DO NOTHING
`

type AssignRoleToUserParams struct {
	UserID int64 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

// Assigns a specific role to a user.
func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const getUserWithAuthorizationContext = `-- name: GetUserWithAuthorizationContext :one
SELECT
    u.id,
    u.email,
    u.first_name,
    u.last_name,
    u.org,
    u.is_active,
    u.created_at,
    COALESCE((SELECT array_agg(r.name) FROM roles r JOIN user_roles ur ON r.id = ur.role_id WHERE ur.user_id = u.id), '{}') AS roles,
    COALESCE((SELECT array_agg(p.action) FROM permissions p JOIN role_permissions rp ON p.id = rp.permission_id JOIN user_roles ur ON rp.role_id = ur.role_id WHERE ur.user_id = u.id), '{}') AS permissions,
    COALESCE((SELECT array_agg(ubla.business_line) FROM user_business_line_access ubla WHERE ubla.user_id = u.id), '{}') AS business_lines
FROM
    "cdms_user" u
WHERE
    u.id = $1
`

type GetUserWithAuthorizationContextRow struct {
	ID            int64              `json:"id"`
	Email         string             `json:"email"`
	FirstName     string             `json:"first_name"`
	LastName      string             `json:"last_name"`
	Org           UserOrg            `json:"org"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Roles         interface{}        `json:"roles"`
	Permissions   interface{}        `json:"permissions"`
	BusinessLines interface{}        `json:"business_lines"`
}

// Fetches a single user by their ID, including their roles, permissions, and business lines.
func (q *Queries) GetUserWithAuthorizationContext(ctx context.Context, id int64) (GetUserWithAuthorizationContextRow, error) {
	row := q.db.QueryRow(ctx, getUserWithAuthorizationContext, id)
	var i GetUserWithAuthorizationContextRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Org,
		&i.IsActive,
		&i.CreatedAt,
		&i.Roles,
		&i.Permissions,
		&i.BusinessLines,
	)
	return i, err
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT
    u.id,
    u.email,
    u.first_name,
    u.last_name,
    u.org,
    u.is_active,
    u.created_at,
    COALESCE((SELECT array_agg(r.name) FROM roles r JOIN user_roles ur ON r.id = ur.role_id WHERE ur.user_id = u.id), '{}') AS roles
FROM
    "cdms_user" u
ORDER BY
    u.last_name, u.first_name
LIMIT $1
OFFSET $2
`

type ListAllUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllUsersRow struct {
	ID        int64              `json:"id"`
	Email     string             `json:"email"`
	FirstName string             `json:"first_name"`
	LastName  string             `json:"last_name"`
	Org       UserOrg            `json:"org"`
	IsActive  bool               `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Roles     interface{}        `json:"roles"`
}

// Fetches a paginated list of all users. For super_admins and global admins.
func (q *Queries) ListAllUsers(ctx context.Context, arg ListAllUsersParams) ([]ListAllUsersRow, error) {
	rows, err := q.db.Query(ctx, listAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllUsersRow
	for rows.Next() {
		var i ListAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Org,
			&i.IsActive,
			&i.CreatedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description FROM "roles" ORDER BY id
`

// Fetches all available roles in the system.
func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByBusinessLines = `-- name: ListUsersByBusinessLines :many
SELECT
    u.id,
    u.email,
    u.first_name,
    u.last_name,
    u.org,
    u.is_active,
    u.created_at,
    COALESCE((SELECT array_agg(r.name) FROM roles r JOIN user_roles ur ON r.id = ur.role_id WHERE ur.user_id = u.id), '{}') AS roles
FROM
    "cdms_user" u
WHERE u.id IN (
    SELECT DISTINCT ubla.user_id
    FROM user_business_line_access ubla
    WHERE ubla.business_line = ANY($3::chargeback_business_line[])
)
ORDER BY
    u.last_name, u.first_name
LIMIT $1
OFFSET $2
`

type ListUsersByBusinessLinesParams struct {
	Limit         int32                    `json:"limit"`
	Offset        int32                    `json:"offset"`
	BusinessLines []ChargebackBusinessLine `json:"business_lines"`
}

type ListUsersByBusinessLinesRow struct {
	ID        int64              `json:"id"`
	Email     string             `json:"email"`
	FirstName string             `json:"first_name"`
	LastName  string             `json:"last_name"`
	Org       UserOrg            `json:"org"`
	IsActive  bool               `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Roles     interface{}        `json:"roles"`
}

// Fetches a paginated list of users who are associated with a given set of business lines.
// This is for scoped admins.
func (q *Queries) ListUsersByBusinessLines(ctx context.Context, arg ListUsersByBusinessLinesParams) ([]ListUsersByBusinessLinesRow, error) {
	rows, err := q.db.Query(ctx, listUsersByBusinessLines, arg.Limit, arg.Offset, arg.BusinessLines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersByBusinessLinesRow
	for rows.Next() {
		var i ListUsersByBusinessLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Org,
			&i.IsActive,
			&i.CreatedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllRolesFromUser = `-- name: RemoveAllRolesFromUser :exec
DELETE FROM "user_roles" WHERE user_id = $1
`

// Removes all roles from a user.
func (q *Queries) RemoveAllRolesFromUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, removeAllRolesFromUser, userID)
	return err
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM "user_roles" WHERE user_id = $1 AND role_id = $2
`

type RemoveRoleFromUserParams struct {
	UserID int64 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

// Removes a specific role from a user.
func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, removeRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "cdms_user"
SET
    first_name = $2,
    last_name = $3,
    org = $4,
    is_active = $5
WHERE
    id = $1
RETURNING id, auth_provider_subject, email, first_name, last_name, org, is_active, updated_at, created_at
`

type UpdateUserParams struct {
	ID        int64   `json:"id"`
	FirstName string  `json:"first_name"`
	LastName  string  `json:"last_name"`
	Org       UserOrg `json:"org"`
	IsActive  bool    `json:"is_active"`
}

// Updates a user's mutable details.
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (CdmsUser, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Org,
		arg.IsActive,
	)
	var i CdmsUser
	err := row.Scan(
		&i.ID,
		&i.AuthProviderSubject,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Org,
		&i.IsActive,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
